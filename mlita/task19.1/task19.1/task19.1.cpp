//| Задание 19.1 | Садовин Владислав, ПС-22 | Microsoft Visual Studio |
/*19.1.Кроссворд 2 (3)
Кроссворд размещен в квадрате.Строки и столбцы квадрата нумеруются снизу вверх и слева
направо, начиная с 1. Поля для слов располагаются горизонтально либо вертикально и задаются
путем указания координат начальной и конечной клеток.Какая - либо сортировка при задании
полей отсутствует.Два пересекающихся слова могут располагаться как на одной горизонтали либо
вертикали, так и перпендикулярно друг другу.Подсчитать количество занятых клеток кроссворда.
Ввод.В первой строке файла INPUT.TXT заданы размер квадрата M(1 ≤ M ≤ 50) и количество
слов кроссворда N(1 ≤ N ≤ 20).В следующих N строках указываются координаты(a i, b i) начальной
и конечной клеток очередного слова(1 ≤ a i, b i ≤ M).
Вывод.В единственной строке выходного файла OUTPUT.TXT должно содержаться общее
количество занятых клеток кроссворда.
Пример
Ввод
10 2
2 3 3 3
1 3 4 3
Вывод
4*/
//////////////////////////////
/*Я как понял, что в задании нужно сосчитать количество занятых клеток. Но занятые клетки это же не только начальный и конечный
клетки, но и те клетки, которые расположены между ними?
Если в тесте
15 2
2 3 2 2
1 3 4 3
должно быть 4, я не совсем понимаю само задание. Если считать только начальный и конечный клетки, то зачем нам их координаты?
Ведь зная количество слов, мы сразу же можеи сосчитать кол-вл занятых клеток (2 * кол-во слов) */
#include "pch.h"
#include <iostream>
#include <fstream>

using namespace std;

int main()
{
	ifstream inputFile("INPUT.txt");
	ofstream outputFile("OUTPUT.txt");

	int M, N, x1, y1, x2, y2, cellCount = 0;
	inputFile >> M >> N;

	int **crosswordField = new int*[M];
	for (int i = 0; i != M; i++)
	{
		crosswordField[i] = new int[M];
	}

	for (int i = 0; i != N; i++)
	{
		inputFile >> x1 >> y1 >> x2 >> y2;
		for (int j = x1; j != x2 + 1; j++) 
		{
			for (int k = y2; k != y1 + 1; k++)
			{
			     crosswordField[j][k] = 1;
			}
		}
	}

	for (int j = 0; j != M; j++)
	{
		for (int i = 0; i != M; i++)
		{
			if (crosswordField[i][j] == 1) 
			{
				cellCount++;
			}
		}
	}
	outputFile << cellCount << endl;
}
